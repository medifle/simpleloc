package processor

import (
	"encoding/base64"
	"fmt"
	jsoniter "github.com/json-iterator/go"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

// Language config loaded from Constants.go which is generated from languages.json by `go generate`
var ExtensionToLanguage = map[string]string{}
var LangFeature = LanguageFeature{}

// ProcessConstants processes loaded language config
func ProcessConstants(extension string) error {
	languageConfig := loadLanguageConfig()

	// Get the mapping from extension to language name
	for key, value := range languageConfig {
		for _, ext := range value.Extensions {
			ExtensionToLanguage[ext] = key
		}
	}
	languageName, ok := ExtensionToLanguage[extension]
	if !ok {
		return fmt.Errorf("extension %s is not supported", extension)
	}

	/*
	 * Get language config to LanguageFeature for further processing
	 */
	language, _ := languageConfig[languageName]

	singleLineComments := [][]byte{}
	multiLineComments := []OpenClose{}
	quotes := []Quote{}

	for _, value := range language.LineComment {
		singleLineComments = append(singleLineComments, []byte(value))
	}

	for _, value := range language.MultiLine {
		multiLineComments = append(multiLineComments, OpenClose{
			Open:  []byte(value[0]),
			Close: []byte(value[1]),
		})
	}

	for _, value := range language.Quotes {
		quotes = append(quotes, Quote{
			Start: value.Start,
			End:   value.End,
		})
	}

	LangFeature = LanguageFeature{
		SingleLineComments: singleLineComments,
		MultiLineComments:  multiLineComments,
		Quotes:             quotes,
	}

	return nil
}

// loadLanguageConfig loads language config from constants.go which is pre-generated by `go generate`
func loadLanguageConfig() map[string]Language {
	var config map[string]Language

	decodedData, err := base64.StdEncoding.DecodeString(languages)
	if err != nil {
		panic(fmt.Sprintf("failed to decode base64 languages: %v", err))
	}

	json := jsoniter.ConfigCompatibleWithStandardLibrary
	if err := json.Unmarshal(decodedData, &config); err != nil {
		panic(fmt.Sprintf("invalid languages json format: %v", err))
	}

	return config
}

func printStats(file *File) {
	fmt.Printf("Total # of lines: %d\n", file.Lines)
	fmt.Printf("Total # of comment lines: %d\n", file.SingleLineComment+file.MultiLineComment)
	fmt.Printf("Total # of single line comments: %d\n", file.SingleLineComment)
	fmt.Printf("Total # of comment lines within block comments: %d\n", file.MultiLineComment)
	fmt.Printf("Total # of block line comments: %d\n", file.BlockComment)
	fmt.Printf("Total # of TODOâ€™s: %d\n", file.Todo)
	fmt.Println()
}

func getExtension(filePath string) (string, error) {
	extension := filepath.Ext(filePath)
	if len(extension) == 0 {
		return "", fmt.Errorf("file extension is empty\n")
	}

	extension = strings.ToLower(extension)
	return strings.Split(extension, ".")[1], nil
}

func IsDirectory(path string) bool {
	fileInfo, err := os.Stat(path)
	if err != nil {
		return false
	}
	return fileInfo.IsDir()
}

func Process() {
	// Parse CLI argument
	if len(os.Args) <= 1 {
		fmt.Println("usage: simpleloc <filepath>")
		return
	}
	filePath := os.Args[1]

	if IsDirectory(filePath) {
		fmt.Println("please specify a file, not folder")
		return
	}

	// Read the entire file content into memory
	content, err := ioutil.ReadFile(filePath)
	if err != nil {
		fmt.Println(err)
		return
	}

	extension, err := getExtension(filePath)
	if err != nil {
		fmt.Printf(err.Error())
		return
	}

	file := &File{
		Extension: extension,
		Content:   content,
	}

	if err := ProcessConstants(extension); err != nil {
		fmt.Printf("cannot process language config: %s\n", err.Error())
		return
	}

	// Count lines
	countStats(file)

	// Output the result
	printStats(file)
}
